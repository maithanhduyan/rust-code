# BiBank - AI Coding Instructions

## Project Vision
BiBank is a **Financial State OS** - NOT a traditional banking app. Core principles:
- **Ledger is the single source of truth** - No DB can "mutate state" directly
- **No reconciliation** - If reconciliation is needed → architecture is wrong
- **Correct-by-construction** - Risk engine blocks invalid state at write-time
- **Event-first** - State is projection, events are truth (JSONL files)

## Architecture
```
           ┌────────────┐
           │ Risk Engine│ (Pre-commit Gatekeeper)
           └─────▲──────┘
                 │ check()
Client ──▶ Ledger ──▶ Event Bus ──▶ Projections (SQLite)
                 │
                 ▼
           Audit / Replay
```

## Workspace: 9 Crates
| Crate | Role | Key Types |
|-------|------|-----------|
| `bibank-core` | Domain types | `Amount` (non-negative Decimal), `Currency` |
| `bibank-ledger` | **[HEART]** Double-entry | `AccountKey`, `JournalEntry`, `Posting`, `TransactionIntent` |
| `bibank-risk` | **[GATEKEEPER]** Pre-commit | `RiskEngine`, `RiskState`, `InterestCalculator`, `MarginError` |
| `bibank-oracle` | Price feeds | `PriceOracle` trait, `MockOracle` |
| `bibank-events` | JSONL store | `EventWriter`, `EventReader` |
| `bibank-bus` | Event distribution | `EventBus` |
| `bibank-projection` | SQLite views | Disposable, rebuildable from events |
| `bibank-rpc` | CLI orchestrator | `AppContext` (main integration point) |
| `bibank-dsl` | DSL macros | Future |

## Critical Patterns

### Double-Entry Accounting
Every `JournalEntry` MUST have **zero-sum per asset**:
```rust
// Deposit 100 USDT to Alice
JournalEntryBuilder::new()
    .intent(TransactionIntent::Deposit)
    .correlation_id("deposit-123")
    .debit(AccountKey::system_vault("USDT"), amount(100))
    .credit(AccountKey::user_available("ALICE", "USDT"), amount(100))
    .build_unsigned()
```

### Account Key (5-part hierarchical)
```
CATEGORY:SEGMENT:ID:ASSET:SUB_ACCOUNT
LIAB:USER:ALICE:USDT:AVAILABLE   # User's available balance
ASSET:USER:ALICE:USDT:LOAN       # User's loan (BiBank's receivable) [Phase 3]
LIAB:USER:ALICE:USDT:LOCKED      # Funds locked in orders [Phase 3]
```
Categories: `ASSET`, `LIAB`, `EQUITY`, `REV`, `EXP`

### Transaction Intents
| Phase | Intents |
|-------|---------|
| 1 | `Genesis`, `Deposit`, `Withdrawal`, `Transfer` |
| 2 | `Trade`, `Fee`, `Adjustment` |
| 3 | `Borrow`, `Repay`, `Interest`, `Liquidation`, `OrderPlace`, `OrderCancel` |

### Margin Trading Formulas [Phase 3]
```
Equity = Available - Loan
Margin Ratio = Available / Loan  (>1.0 = safe, <1.0 = liquidate)
Max Leverage = 10x (configurable)
Daily Interest = 0.05% (compound)
```

## Invariants - NEVER Violate
1. Ledger is **append-only** - No update/delete
2. Every entry has **strictly increasing sequence**
3. Hash chain: `prev_hash` = SHA256 of previous entry
4. Risk Engine checks **BEFORE** ledger commit (not after)
5. Risk Engine uses **in-memory state only** (rebuilt from replay)
6. `Amount` is always non-negative (type-enforced)
7. `correlation_id` is REQUIRED, generated by caller (not ledger)

## Test Commands
```bash
cargo test                    # All tests (~100+)
cargo test -p bibank-ledger   # Ledger crate only
cargo test validation         # Filter by test name
cargo test -p bibank-rpc margin # Integration tests filtered
```

## Key Files & Patterns
| File | Pattern |
|------|---------|
| `crates/ledger/src/validation.rs` | Intent-specific validation rules |
| `crates/risk/src/state.rs` | Balance tracking, margin calculation |
| `crates/risk/src/interest.rs` | Compound interest generation |
| `crates/oracle/src/mock.rs` | Price feed implementation |
| `crates/rpc/tests/integration.rs` | Full workflow tests |

## Adding New Transaction Intent
1. Add variant to `TransactionIntent` enum in `entry.rs`
2. Add validation function in `validation.rs`
3. Add match arm in `validate_intent()`
4. Add unit tests for success/failure cases
5. Update integration tests in `crates/rpc/tests/`

## Anti-Patterns to Avoid
- ❌ Mutating balance directly (`balance += amount`)
- ❌ Reading SQLite in Risk Engine
- ❌ Single-entry transactions (always double-entry)
- ❌ Generating `correlation_id` inside ledger
- ❌ Using `HashMap<String, String>` for metadata (use `serde_json::Value`)
- ❌ Skipping sequence numbers
