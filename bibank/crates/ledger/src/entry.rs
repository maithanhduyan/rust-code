//! Journal Entry - The atomic unit of financial state change

use crate::account::AccountKey;
use crate::error::LedgerError;
use bibank_core::Amount;
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Transaction intent - Financial primitive (NOT workflow)
///
/// Each intent represents a specific type of financial operation.
/// The ledger validates entries based on their intent.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TransactionIntent {
    /// System initialization - creates initial balances
    Genesis,

    /// External money entering the system
    Deposit,

    /// External money leaving the system
    Withdrawal,

    /// Internal transfer between accounts
    Transfer,

    /// Exchange between different assets
    Trade,

    /// Fee collection
    Fee,

    /// Manual adjustment (audit-heavy, requires approval)
    Adjustment,
}

/// Posting side - Debit or Credit
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Side {
    /// Debit - increases assets/expenses, decreases liabilities/equity/revenue
    Debit,

    /// Credit - decreases assets/expenses, increases liabilities/equity/revenue
    Credit,
}

/// A single posting within a journal entry
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Posting {
    /// The ledger account being affected
    pub account: AccountKey,

    /// The amount (always positive)
    pub amount: Amount,

    /// Debit or Credit
    pub side: Side,
}

impl Posting {
    /// Create a new posting
    pub fn new(account: AccountKey, amount: Amount, side: Side) -> Self {
        Self {
            account,
            amount,
            side,
        }
    }

    /// Create a debit posting
    pub fn debit(account: AccountKey, amount: Amount) -> Self {
        Self::new(account, amount, Side::Debit)
    }

    /// Create a credit posting
    pub fn credit(account: AccountKey, amount: Amount) -> Self {
        Self::new(account, amount, Side::Credit)
    }

    /// Get the signed amount for balance calculation
    /// Debit = positive, Credit = negative
    pub fn signed_amount(&self) -> Decimal {
        match self.side {
            Side::Debit => self.amount.value(),
            Side::Credit => -self.amount.value(),
        }
    }
}

/// Journal Entry - The atomic unit of financial state change
///
/// Every entry MUST be double-entry balanced (zero-sum per asset).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JournalEntry {
    // === Ordering & Integrity ===
    /// Global sequence number (strictly increasing)
    pub sequence: u64,

    /// SHA256 hash of previous entry (or "GENESIS" for first entry)
    pub prev_hash: String,

    /// SHA256 hash of this entry's content
    pub hash: String,

    /// Timestamp when the entry was created
    pub timestamp: DateTime<Utc>,

    // === Semantics ===
    /// The type of financial operation
    pub intent: TransactionIntent,

    // === Tracing ===
    /// Request UUID from API/CLI (REQUIRED, never generated by ledger)
    pub correlation_id: String,

    /// Optional link to parent entry that caused this entry
    pub causality_id: Option<String>,

    // === Financial Data ===
    /// The list of postings (debits and credits)
    pub postings: Vec<Posting>,

    // === Metadata ===
    /// Additional metadata (opaque to ledger, used by audit/projection)
    #[serde(default)]
    pub metadata: HashMap<String, serde_json::Value>,
}

impl JournalEntry {
    /// Validate the entry according to ledger invariants
    ///
    /// # Rules
    /// 1. At least 2 postings (double-entry)
    /// 2. Zero-sum per asset group
    /// 3. Non-empty correlation_id
    /// 4. Genesis entries have special requirements
    pub fn validate(&self) -> Result<(), LedgerError> {
        // Rule: correlation_id cannot be empty
        if self.correlation_id.is_empty() {
            return Err(LedgerError::EmptyCorrelationId);
        }

        // Rule: At least 2 postings
        if self.postings.len() < 2 {
            return Err(LedgerError::InsufficientPostings);
        }

        // Rule: Genesis entry special requirements
        if self.intent == TransactionIntent::Genesis {
            if self.sequence != 1 {
                return Err(LedgerError::InvalidGenesisSequence);
            }
            if self.prev_hash != "GENESIS" {
                return Err(LedgerError::InvalidGenesisPrevHash);
            }
        }

        // Rule: Zero-sum per asset
        let mut sums: HashMap<String, Decimal> = HashMap::new();
        for posting in &self.postings {
            let asset = &posting.account.asset;
            *sums.entry(asset.clone()).or_default() += posting.signed_amount();
        }

        for (asset, sum) in sums {
            if !sum.is_zero() {
                return Err(LedgerError::UnbalancedEntry {
                    asset,
                    imbalance: sum,
                });
            }
        }

        Ok(())
    }

    /// Get all unique assets in this entry
    pub fn assets(&self) -> Vec<String> {
        let mut assets: Vec<_> = self
            .postings
            .iter()
            .map(|p| p.account.asset.clone())
            .collect();
        assets.sort();
        assets.dedup();
        assets
    }
}

/// Builder for creating JournalEntry with fluent API
#[derive(Debug, Default)]
pub struct JournalEntryBuilder {
    intent: Option<TransactionIntent>,
    correlation_id: Option<String>,
    causality_id: Option<String>,
    postings: Vec<Posting>,
    metadata: HashMap<String, serde_json::Value>,
}

impl JournalEntryBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn intent(mut self, intent: TransactionIntent) -> Self {
        self.intent = Some(intent);
        self
    }

    pub fn correlation_id(mut self, id: impl Into<String>) -> Self {
        self.correlation_id = Some(id.into());
        self
    }

    pub fn causality_id(mut self, id: impl Into<String>) -> Self {
        self.causality_id = Some(id.into());
        self
    }

    pub fn posting(mut self, posting: Posting) -> Self {
        self.postings.push(posting);
        self
    }

    pub fn debit(mut self, account: AccountKey, amount: Amount) -> Self {
        self.postings.push(Posting::debit(account, amount));
        self
    }

    pub fn credit(mut self, account: AccountKey, amount: Amount) -> Self {
        self.postings.push(Posting::credit(account, amount));
        self
    }

    pub fn metadata(mut self, key: impl Into<String>, value: serde_json::Value) -> Self {
        self.metadata.insert(key.into(), value);
        self
    }

    /// Build the entry (sequence, prev_hash, hash, timestamp will be set by ledger)
    pub fn build_unsigned(self) -> Result<UnsignedEntry, LedgerError> {
        let intent = self.intent.unwrap_or(TransactionIntent::Transfer);
        let correlation_id = self
            .correlation_id
            .ok_or(LedgerError::EmptyCorrelationId)?;

        if correlation_id.is_empty() {
            return Err(LedgerError::EmptyCorrelationId);
        }

        if self.postings.len() < 2 {
            return Err(LedgerError::InsufficientPostings);
        }

        let unsigned = UnsignedEntry {
            intent,
            correlation_id,
            causality_id: self.causality_id,
            postings: self.postings,
            metadata: self.metadata,
        };

        // Validate double-entry balance before returning
        unsigned.validate_balance()?;

        Ok(unsigned)
    }
}

/// An entry that hasn't been signed with sequence/hash yet
#[derive(Debug, Clone)]
pub struct UnsignedEntry {
    pub intent: TransactionIntent,
    pub correlation_id: String,
    pub causality_id: Option<String>,
    pub postings: Vec<Posting>,
    pub metadata: HashMap<String, serde_json::Value>,
}

impl UnsignedEntry {
    /// Validate double-entry balance
    pub fn validate_balance(&self) -> Result<(), LedgerError> {
        let mut sums: HashMap<String, Decimal> = HashMap::new();
        for posting in &self.postings {
            let asset = &posting.account.asset;
            *sums.entry(asset.clone()).or_default() += posting.signed_amount();
        }

        for (asset, sum) in sums {
            if !sum.is_zero() {
                return Err(LedgerError::UnbalancedEntry {
                    asset,
                    imbalance: sum,
                });
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal::Decimal;

    fn amount(val: i64) -> Amount {
        Amount::new(Decimal::new(val, 0)).unwrap()
    }

    #[test]
    fn test_balanced_entry() {
        let entry = JournalEntry {
            sequence: 1,
            prev_hash: "GENESIS".to_string(),
            hash: "test".to_string(),
            timestamp: Utc::now(),
            intent: TransactionIntent::Genesis,
            correlation_id: "test-123".to_string(),
            causality_id: None,
            postings: vec![
                Posting::debit(AccountKey::system_vault("USDT"), amount(1000)),
                Posting::credit(
                    AccountKey::new(
                        crate::AccountCategory::Equity,
                        "SYSTEM",
                        "CAPITAL",
                        "USDT",
                        "MAIN",
                    ),
                    amount(1000),
                ),
            ],
            metadata: HashMap::new(),
        };

        assert!(entry.validate().is_ok());
    }

    #[test]
    fn test_unbalanced_entry() {
        let entry = JournalEntry {
            sequence: 2,
            prev_hash: "abc".to_string(),
            hash: "test".to_string(),
            timestamp: Utc::now(),
            intent: TransactionIntent::Deposit,
            correlation_id: "test-123".to_string(),
            causality_id: None,
            postings: vec![
                Posting::debit(AccountKey::system_vault("USDT"), amount(100)),
                Posting::credit(AccountKey::user_available("ALICE", "USDT"), amount(50)),
            ],
            metadata: HashMap::new(),
        };

        let result = entry.validate();
        assert!(matches!(result, Err(LedgerError::UnbalancedEntry { .. })));
    }

    #[test]
    fn test_multi_asset_trade() {
        let entry = JournalEntry {
            sequence: 2,
            prev_hash: "abc".to_string(),
            hash: "test".to_string(),
            timestamp: Utc::now(),
            intent: TransactionIntent::Trade,
            correlation_id: "test-123".to_string(),
            causality_id: None,
            postings: vec![
                // USDT leg: Alice pays, Bob receives
                Posting::debit(AccountKey::user_available("ALICE", "USDT"), amount(100)),
                Posting::credit(AccountKey::user_available("BOB", "USDT"), amount(100)),
                // BTC leg: Bob pays, Alice receives
                Posting::debit(AccountKey::user_available("BOB", "BTC"), amount(1)),
                Posting::credit(AccountKey::user_available("ALICE", "BTC"), amount(1)),
            ],
            metadata: HashMap::new(),
        };

        assert!(entry.validate().is_ok());
        assert_eq!(entry.assets(), vec!["BTC", "USDT"]);
    }

    #[test]
    fn test_empty_correlation_id() {
        let entry = JournalEntry {
            sequence: 1,
            prev_hash: "GENESIS".to_string(),
            hash: "test".to_string(),
            timestamp: Utc::now(),
            intent: TransactionIntent::Genesis,
            correlation_id: "".to_string(),
            causality_id: None,
            postings: vec![
                Posting::debit(AccountKey::system_vault("USDT"), amount(1000)),
                Posting::credit(
                    AccountKey::new(
                        crate::AccountCategory::Equity,
                        "SYSTEM",
                        "CAPITAL",
                        "USDT",
                        "MAIN",
                    ),
                    amount(1000),
                ),
            ],
            metadata: HashMap::new(),
        };

        assert!(matches!(
            entry.validate(),
            Err(LedgerError::EmptyCorrelationId)
        ));
    }

    #[test]
    fn test_builder() {
        let unsigned = JournalEntryBuilder::new()
            .intent(TransactionIntent::Deposit)
            .correlation_id("req-123")
            .debit(AccountKey::system_vault("USDT"), amount(100))
            .credit(AccountKey::user_available("ALICE", "USDT"), amount(100))
            .build_unsigned()
            .unwrap();

        assert_eq!(unsigned.intent, TransactionIntent::Deposit);
        assert_eq!(unsigned.postings.len(), 2);
        assert!(unsigned.validate_balance().is_ok());
    }
}
