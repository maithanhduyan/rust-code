//! Fill (trade match) structures

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::order::{OrderId, OrderSide, TradingPair};

/// Unique fill identifier
pub type FillId = String;

/// A fill represents a matched trade between two orders
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fill {
    /// Unique fill ID
    pub id: FillId,
    /// Trading pair
    pub pair: TradingPair,
    /// Taker order ID (the incoming order that triggered the match)
    pub taker_order_id: OrderId,
    /// Maker order ID (the resting order in the book)
    pub maker_order_id: OrderId,
    /// Taker user ID
    pub taker_user_id: String,
    /// Maker user ID
    pub maker_user_id: String,
    /// Taker side (Buy or Sell)
    pub taker_side: OrderSide,
    /// Execution price (maker's limit price)
    pub price: Decimal,
    /// Fill quantity
    pub quantity: Decimal,
    /// Timestamp of the fill
    pub timestamp: DateTime<Utc>,
}

impl Fill {
    /// Create a new fill
    pub fn new(
        pair: TradingPair,
        taker_order_id: OrderId,
        maker_order_id: OrderId,
        taker_user_id: impl Into<String>,
        maker_user_id: impl Into<String>,
        taker_side: OrderSide,
        price: Decimal,
        quantity: Decimal,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            pair,
            taker_order_id,
            maker_order_id,
            taker_user_id: taker_user_id.into(),
            maker_user_id: maker_user_id.into(),
            taker_side,
            price,
            quantity,
            timestamp: Utc::now(),
        }
    }

    /// Notional value of the fill (price * quantity)
    pub fn notional_value(&self) -> Decimal {
        self.price * self.quantity
    }

    /// Get the buyer user ID
    pub fn buyer_id(&self) -> &str {
        match self.taker_side {
            OrderSide::Buy => &self.taker_user_id,
            OrderSide::Sell => &self.maker_user_id,
        }
    }

    /// Get the seller user ID
    pub fn seller_id(&self) -> &str {
        match self.taker_side {
            OrderSide::Buy => &self.maker_user_id,
            OrderSide::Sell => &self.taker_user_id,
        }
    }
}

/// Result of a match operation
#[derive(Debug, Clone, Default)]
pub struct MatchResult {
    /// List of fills generated by the match
    pub fills: Vec<Fill>,
    /// Remaining quantity of the taker order (0 if fully filled)
    pub remaining_quantity: Decimal,
    /// Whether the taker order was fully filled
    pub fully_filled: bool,
}

impl MatchResult {
    /// Create an empty match result (no fills)
    pub fn empty(remaining: Decimal) -> Self {
        Self {
            fills: Vec::new(),
            remaining_quantity: remaining,
            fully_filled: false,
        }
    }

    /// Total quantity filled
    pub fn total_filled(&self) -> Decimal {
        self.fills.iter().map(|f| f.quantity).sum()
    }

    /// Total notional value of all fills
    pub fn total_notional(&self) -> Decimal {
        self.fills.iter().map(|f| f.notional_value()).sum()
    }

    /// Average execution price (if any fills)
    pub fn average_price(&self) -> Option<Decimal> {
        let total_qty = self.total_filled();
        if total_qty > Decimal::ZERO {
            Some(self.total_notional() / total_qty)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fill_creation() {
        let fill = Fill::new(
            TradingPair::btc_usdt(),
            "order-1".to_string(),
            "order-2".to_string(),
            "ALICE",
            "BOB",
            OrderSide::Buy,
            Decimal::from(50000),
            Decimal::from(1),
        );

        assert_eq!(fill.taker_user_id, "ALICE");
        assert_eq!(fill.maker_user_id, "BOB");
        assert_eq!(fill.notional_value(), Decimal::from(50000));
    }

    #[test]
    fn test_fill_buyer_seller() {
        // Taker is buyer
        let fill = Fill::new(
            TradingPair::btc_usdt(),
            "order-1".to_string(),
            "order-2".to_string(),
            "ALICE",
            "BOB",
            OrderSide::Buy,
            Decimal::from(50000),
            Decimal::from(1),
        );
        assert_eq!(fill.buyer_id(), "ALICE");
        assert_eq!(fill.seller_id(), "BOB");

        // Taker is seller
        let fill = Fill::new(
            TradingPair::btc_usdt(),
            "order-1".to_string(),
            "order-2".to_string(),
            "ALICE",
            "BOB",
            OrderSide::Sell,
            Decimal::from(50000),
            Decimal::from(1),
        );
        assert_eq!(fill.buyer_id(), "BOB");
        assert_eq!(fill.seller_id(), "ALICE");
    }

    #[test]
    fn test_match_result() {
        let mut result = MatchResult::empty(Decimal::from(1));

        result.fills.push(Fill::new(
            TradingPair::btc_usdt(),
            "order-1".to_string(),
            "order-2".to_string(),
            "ALICE",
            "BOB",
            OrderSide::Buy,
            Decimal::from(50000),
            Decimal::from_str_exact("0.5").unwrap(),
        ));

        result.fills.push(Fill::new(
            TradingPair::btc_usdt(),
            "order-1".to_string(),
            "order-3".to_string(),
            "ALICE",
            "CAROL",
            OrderSide::Buy,
            Decimal::from(50100),
            Decimal::from_str_exact("0.5").unwrap(),
        ));

        assert_eq!(result.total_filled(), Decimal::from(1));
        assert_eq!(result.total_notional(), Decimal::from(50050));
        assert_eq!(result.average_price(), Some(Decimal::from(50050)));
    }
}
